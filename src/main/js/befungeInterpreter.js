/*
    Befunge Interpreter
    https://www.codewars.com/kata/526c7b931666d07889000a3c

Esoteric languages are pretty hard to program, but it's fairly interesting to write interpreters for them!

Your task is to write a method which will interpret Befunge-93 code! Befunge-93 is a language in which the code is
presented not as a series of instructions, but as instructions scattered on a 2D plane; your pointer starts at the
top-left corner and defaults to moving right through the code. Note that the instruction pointer wraps around the screen!
There is a singular stack which we will assume is unbounded and only contain integers. While Befunge-93 code is supposed
to be restricted to 80x25, you need not be concerned with code size. Befunge-93 supports the following instructions
(from Wikipedia):
    0-9 Push this number onto the stack.
    + Addition: Pop a and b, then push a+b.
    - Subtraction: Pop a and b, then push b-a.
    * Multiplication: Pop a and b, then push a*b.
    / Integer division: Pop a and b, then push b/a, rounded down. If a is zero, push zero.
    % Modulo: Pop a and b, then push the b%a. If a is zero, push zero.
    ! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero.
    ` (backtick) Greater than: Pop a and b, then push 1 if b>a, otherwise push zero.
    > Start moving right.
    < Start moving left.
    ^ Start moving up.
    v Start moving down.
    ? Start moving in a random cardinal direction.
    _ Pop a value; move right if value = 0, left otherwise.
    | Pop a value; move down if value = 0, up otherwise.
    " Start string mode: push each character's ASCII value all the way up to the next ".
    : Duplicate value on top of the stack. If there is nothing on top of the stack, push a 0.
    \ Swap two values on top of the stack. If there is only one value, pretend there is an extra 0 on bottom of the stack.
    $ Pop value from the stack and discard it.
    . Pop value and output as an integer.
    , Pop value and output the ASCII character represented by the integer code that is stored in the value.
    # Trampoline: Skip next cell.
    p A "put" call (a way to store a value for later use). Pop y, x and v, then change the character at the position (x,y) in the program to the character with ASCII value v.
    g A "get" call (a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program.
    @ End program.
      (i.e. a space) No-op. Does nothing.

The above list is slightly modified: you'll notice if you look at the Wikipedia page that we do not use the user input
instructions and dividing by zero simply yields zero.

Here's an example:
    >987v>.v
    v456<  :
    >321 ^ _@
will create the output 123456789.

So what you must do is create a function such that when you pass in the Befunge code, the function returns the output
that would be generated by the code. So, for example:
    "123456789".equals(new BefungeInterpreter().interpret(">987v>.v\nv456<  :\n>321 ^ _@")

This test case will be added for you.
*/

const DIRECTION = {
  RIGHT: '>',
  LEFT: '<',
  UP: '^',
  DOWN: 'v',
  getRandom() {
    switch (Math.floor(Math.random()*4)) {
      case 0: return DIRECTION.RIGHT;
      case 1: return DIRECTION.LEFT;
      case 2: return DIRECTION.UP;
      default: return DIRECTION.DOWN;
    }
  }
};

class Program {
  constructor(code1d) {
    this.code = [];
    code1d.split('\n').forEach(line => {
      this.code.push(line.split(''));
    });

    this.pos = {
      x: 0,
      y: 0,
      direction: DIRECTION.RIGHT
    };

    this.stack = [];
    this.output = '';
  }

  get height() {
    return this.code.length;
  }

  get width() {
    return this.code[this.pos.y].length;
  }

  get command() {
    return this.code[this.pos.y][this.pos.x];
  }

  set direction(val) {
    this.pos.direction = val;
  }

  pushValue(val) {
    this.stack.push(val);
  }

  popValue() {
    return this.stack.pop();
  }

  peakValue() {
    return this.stack[this.stack.length - 1];
  }

  move(direction) {
    // console.log(`(${this.pos.x}, ${this.pos.y}) = '${this.command}', direction: ${this.pos.direction}, stack = ${this.stack}`);
    direction = direction || this.pos.direction;
    switch (direction) {
      case DIRECTION.RIGHT:
        this.pos.x = this.pos.x === this.width + 1 ? 0 : this.pos.x + 1;
        break;
      case DIRECTION.LEFT:
        this.pos.x = this.pos.x === 0 ? this.width - 1 : this.pos.x - 1;
        break;
      case DIRECTION.UP:
        this.pos.y = this.pos.y === 0 ? this.height - 1 : this.pos.y - 1;
        break;
      case DIRECTION.DOWN:
        this.pos.y = this.pos.y === this.height + 1 ? 0 : this.pos.y + 1;
        break;
    }
  }

  updateCommand(x, y, v) {
    this.code[y][x] = v;
  }

  readCommand(x, y) {
    return this.code[y][x];
  }

  printCode() {
    this.code.forEach(line => console.log(line));
  }

  run() {
    // this.printCode();
    while (true) {
      switch (this.command) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          this.pushValue(parseInt(this.command));
          break;

        case '+':
          this.pushValue(this.popValue() + this.popValue());
          break;

        case '-':
          this.pushValue(-(this.popValue() - this.popValue()));
          break;

        case '*':
          this.pushValue(this.popValue() * this.popValue());
          break;

        case '/': {
          const a = this.popValue();
          const b = this.popValue();
          this.pushValue(a === 0 ? 0 : Math.floor(b / a));
        } break;

        case '%': {
          const a = this.popValue();
          const b = this.popValue();
          this.pushValue(a === 0 ? 0 : b % a);
        } break;

        case '!':
          this.pushValue(this.popValue() === 0 ? 1 : 0);
          break;

        case '`': {
          const a = this.popValue();
          const b = this.popValue();
          this.pushValue(b > a ? 1 : 0);
        } break;

        case '>':
          this.direction = DIRECTION.RIGHT;
          break;

        case '<':
          this.direction = DIRECTION.LEFT;
          break;

        case '^':
          this.direction = DIRECTION.UP;
          break;

        case 'v':
          this.direction = DIRECTION.DOWN;
          break;

        case '?':
          this.direction = DIRECTION.getRandom();
          break;

        case '_':
          this.direction = this.popValue() === 0 ? DIRECTION.RIGHT : DIRECTION.LEFT;
          break;

        case '|':
          this.direction = this.popValue() === 0 ? DIRECTION.DOWN : DIRECTION.UP;
          break;

        case '"':
          this.move();
          while (this.command !== '"') {
            this.pushValue(this.command.charCodeAt(0));
            this.move();
          }
          break;

        case ':': {
          const val = this.peakValue();
          if (val === undefined) {
            this.pushValue(0);
          } else {
            this.pushValue(val);
          }
        } break;

        case '\\': {
          const a = this.popValue();
          const b = this.popValue() || 0;
          this.pushValue(a);
          this.pushValue(b);
        } break;

        case '$':
          this.popValue();
          break;

        case '.':
          this.output += parseInt(this.popValue());
          break;

        case ',':
          this.output += String.fromCharCode(this.popValue());
          break;

        case '#':
          this.move();
          break;

        case 'p': {
          const y = this.popValue();
          const x = this.popValue();
          const v = this.popValue();
          this.updateCommand(x, y, String.fromCharCode(parseInt(v)));
        } break;

        case 'g': {
          const y = this.popValue();
          const x = this.popValue();
          const v = this.readCommand(x, y);
          this.pushValue(v.charCodeAt(0));
        } break;

        case '@':
          return this.output;
          break;
      }

      this.move();
    }
  }
}

function interpret(code1d) {
  const program = new Program(code1d);
  return program.run();
}